---------------------
Érdemes a 4 szabályt nem belekódolni a nyájba, hanem lehessen a nyájhoz szabályokat adni (heterogén kollekció), és a moveFlock ciklusban alkalmazhatja azokat az egyedekre. Ezáltal megjelenik majd a dinamikus memóriakezelés is, mert lesz a nyájnak addRule(Rule *) függvénye, és ő szabadítja fel a szabályokat, mikor megszűnik.
 
flock.addRule(new SeparationRule(.....));
 
Jelenleg a Rule-ba bele van kódolva, hogy basicBoidok vectorán dolgozik. Ezzel nincs baj, de lehetne általánosabb is. Ha a BasicBoidokat vector helyett std::list-ben tárolnád, át kellene írni a szabályokat is. A jó megoldás az, ha a Rule vectort átvevő függvényeit sablonná alakítod, amely nem tárolót, hanem range-et (first, last) vesz át. 
 
template <class Iterator>
virtual Vector f(Iterator first, Iterator last, const BasicBoid &);
 
és hívása
 
f(flockMembers.begin(), flockMembers.end(), *current)
 
ahol current természetesen flockMembers+i, de ha a moveFlock iterációja sem indexel, hanem iterátorral járja be a tárolót akkor lehet egy listaiterátor is.
----------------- 
