\label{index_md_README}%
\Hypertarget{index_md_README}%
 \hypertarget{index_autotoc_md1}{}\doxysection{A projekt rövid bemutatása}\label{index_autotoc_md1}
Ez a projekt egy raj (nyáj) mozgásának szimulációját valósítja meg két dimenzióban. A raj tagjai különféle szabályok szerint mozognak, amelyek befolyásolják a gyorsulásukat és így a sebességüket is. A grafikus megjelenítéshez az SFML 2.\+5.\+1-\/es verzót használom. A szimuláció célja a természetben megfigyelhető rajmozgás, rajintelligencia és a különböző viselkedésű rajok modellezése. A rajok egyes egyedei az alábbi négy szabály szerint mozognak\+:

1) {\bfseries{Chasing (Üldözés)}}\+: Minden egyed egy közös célpontot, jelen esetben az egérkurzort \char`\"{}kergeti\char`\"{}, azaz felé gyorsul.

2) {\bfseries{Separation (Szeparáció)}}\+: Az egyedek taszító erőt éreznek a többi egyedtől, és próbálnak távolodni, hogy elkerüljék az ütközést.

3) {\bfseries{Cohesion (Kohézió)}}\+: Az egyedek a közvetlen szomszédaik tömegközéppontja felé gyorsulnak, így összetartóbbá válik a mozgásuk.

4) {\bfseries{Alignment (Igazodás)}}\+: Az egyedek a közvetlen szomszédaik sebességét próbálják felvenni, így egymáshoz igazodva mozognak.

Az alábbiakban ismeretetem a program használatát, felépítését, az egyes tervezési döntések mögötti okokat és esetleges fennmaradt kérdéseket és problémákat, majd kitérek a jövőbeli fejlesztési és bővítési lehetőségekre.\hypertarget{index_autotoc_md2}{}\doxysection{Használat}\label{index_autotoc_md2}
A projekt tartalmaz egy Makefile-\/t, amely Windows és UNIX alapú operációs rendszereken egyaránt működik (Windows 11-\/en és Ubuntu 22.\+04 LTS-\/en fejlesztettem és teszteltem).\hypertarget{index_autotoc_md3}{}\doxysubsection{Fordítás és futtatás}\label{index_autotoc_md3}
1) {\bfseries{Fordítás\+:}} A Makefile segítségével az alábbi módon egyszerűen fordíthatod\+: cd codes make

Illetve ha debug módban szeretnéd elindítani (nem feltétlenül ajánlott, egy kiválasztott egyed aktuális pozíciója kiíródik minden időlépésben)\+: cd codes make debug

2) {\bfseries{A program indítása}}\+: \begin{DoxyVerb}   cd bin
   .\main.exe param1 param2
\end{DoxyVerb}
 ahol\+:


\begin{DoxyItemize}
\item param1 a megjelenő ablak kívánt szélessége pixelben (alapból 1920)
\item param2 a megjelenő ablak kívánt magassága pixelben (alapból 1080)
\end{DoxyItemize}

3) {\bfseries{Boid-\/ok számának megadása}}\+:

Ezután a terminálban kell megadni a szimulációban részt vevő egyedek számát. ~\newline
\hypertarget{index_autotoc_md4}{}\doxysection{Osztályok, jelentésük, használatuk}\label{index_autotoc_md4}
\hypertarget{index_autotoc_md5}{}\doxysubsection{Vector}\label{index_autotoc_md5}
Az általam definiált \mbox{\hyperlink{classVector}{Vector}} osztály egy kétdimenziós vektort valósít meg. Matematikai műveletek elvégzéséhez deiniáltam ezt az osztályt, ugyanis erre nincsen külön STL-\/beli előre definiált osztály. A programban mindenhol használom ezt az osztályt, ugyanis a számítások túlnyomó része a vektoralgebra területéhez tartozik.\hypertarget{index_autotoc_md6}{}\doxysubsection{Basic\+Boid}\label{index_autotoc_md6}
A Boid elnevezés Craig Reynolds 1986-\/os Boids névvel ellátott mesterséges élet projektjéből származik. A Boidok aktuális álllapotát négy változóval modellezem\+:


\begin{DoxyItemize}
\item {\bfseries{speed}}\+: A Boidok sebességét tároló {\itshape \mbox{\hyperlink{classVector}{Vector}}}, amely alapján a Boid pozícióját számolom.
\item {\bfseries{acceleration}}\+: A Boidok gyorsulását tároló {\itshape \mbox{\hyperlink{classVector}{Vector}}}, amely alapjén a Boid sebességét számolom.
\item {\bfseries{current\+Position}}\+: A Boidok aktuális pozícióját tároló {\itshape \mbox{\hyperlink{classVector}{Vector}}}. Ennek {\itshape sf\+::\+Vector2f} típusra való kasztolásával tudom megjeleníteni a Boidokat.
\item {\bfseries{mass}}\+: A Boidok tömegét tároló {\itshape double} érték. Ugyan ezzel a számértékkel inicializálom az egyes Boidokhoz tartozó alakzatokat is, így a nagyobb Boidokhoz nagyobb mértet is tudunk rendelni.
\end{DoxyItemize}

Ezzel a négy változóval teljesen leírható a Boidok minden időpillanatban vett aktuális állapota. A Boidok mozgásánál a koncepcióm az volt, hogy az egyedek szabadon váktoztathatják gyorsulásukat, ugyanakkor a sebességük csak és kizárólag a gyorsulásukon keresztül változtatható, azaz nem felülírható sebességük az erre kijelült metóduson kívül sehol. A Boidok mozgatását a My\+Turn metódussal végzem. Ez egyszerűen a paraméterül kapott gyorsulással felülírja a Boid aktuális gyorsulását, majd kiszámítja a \char`\"{}pillanatnyi sebességét\char`\"{} és ez alapján meghatározza a Boid pillanatnyi pozícióját. Kísérletezés képpen néhány szabálynál (a szabályokról később írok részletesebben) figyelembe vettem, hogy a Boidoknak van \char`\"{}látótere\char`\"{}. A látótér közepének a sebességet vettem, azaz minden egyed a sebességével folyamatosan egy irányba néz. Ebből adódóan kellő távon kívül csak olyan más egyedeket képesek észlelni, amelyek benne vannak a látóterükben. (Ilyen például a \mbox{\hyperlink{classSeparationRule}{Separation\+Rule}}. A gyakorlatban talán ez azt jelenthetné, hogy azt a társát nem fogja megpróbálni kikerülni, amelyikről nem tud, azaz a másik fog csak lelassítani, amelyik észleli a vele szemben lévő egyedet. Bizonyos távolságban ugyanakkor mindenképpen észlelik a környezetükben lévő társaikat, ezt akár felfoghatjuk úgy is, hogy \char`\"{}meghallják\char`\"{} társaikat.)\hypertarget{index_autotoc_md7}{}\doxysubsection{Flock}\label{index_autotoc_md7}
A \mbox{\hyperlink{classFlock}{Flock}} osztály a Boidokból álló rajt hivatott reprezentálni. Az egy rajba rendezett egyedek tudnak egymásra reagálni, más rajokkal egyelőre nem képesek interaktálni, ugyanakkor van lehetőség több raj létrehozására. A Boidokat jelen megvalósításban egy std\+::vector-\/ban tárolom, ugyanakkor minden metódus úgy van implementálva, hogy ezt másféle STL-\/kompatibilis konténerrel is végezhetnénk. A raj szabályainak szabály-\/erősségét jelenleg annak példányosításakor lehet beállítani, ugyanis a raj tartalmazza a rajta értelmezett szabály-\/példányokat (ezt a jövőben szeretném még átalakítani). A \mbox{\hyperlink{classFlock}{Flock}} legfőbb metódusa a move\+Flock, ez felel a raj szabályainak alkalmazásáról, itt számolódik minden Boid pillanatbeli gyorsulás értéke, és ezt adja tovább a Boidok My\+Turn függvényének (az engine\+Time aktuális értékével együtt).\hypertarget{index_autotoc_md8}{}\doxysubsection{Rule}\label{index_autotoc_md8}
A \mbox{\hyperlink{classRule}{Rule}} osztály a három Boidok között ható szabály-\/osztály ősosztálya. Az osztály a CRTP (Curiously Recrring Template Pattern) tervezési minta szerint lett tervezve, aminek lényege, hogy az ősosztály paraméterben megkaphatja a belőle származtatott osztályt. Ez a minta teszi lehetővé, hogy az ősosztályban definiáljunk olyan metódsukoat, amelyek a szűrmaztatott osztály metódusait képesek meghívni. Erre a tervezési mintára jelen esetben azért van szükség, mert ha szerenénk a \mbox{\hyperlink{classFlock}{Flock}} osztályban más fajta STL kompatibilis tárolóban tárolni a \mbox{\hyperlink{classBasicBoid}{Basic\+Boid}} objektumainkat, akkor így nem kell módosítanunk semmit sem a szabályok implementációján, teljesen függetlenek a kapott tároló fajtájától. Ezeken felül a \mbox{\hyperlink{classRule}{Rule}} osztály koherens interfészt szolgáltat a három olyan szabálnyak, amelyek a Boidok között hatnak (ezek a Separation, Cohesion és Alignment). A Chasing szabály azért nem ebből az osztályból származik, mert ugyan hasonló interfésze van a többi szabályhoz, ugyanakkor csupán az aktuálisan vizsgált egyedre, és a kurzor pozíciójára van szüksége a számytásokhoz, nem igényli az egész raj ismeretét.\hypertarget{index_autotoc_md9}{}\doxysubsection{Chasing\+Rule}\label{index_autotoc_md9}
A Chasing (\char`\"{}Üldözés\char`\"{}) szabály mevalósításáért felelős osztály. A kurzor és a paraméterül kapott Boid pozíciójából számolja a gyorsulást, amellyel a Boid a kurzor felé fog gyorsulni az adott időpillanatban. Ennek a szabálynak adtam a legnagyobb súlyt, ugyanis szerintem ez a leglátványosabb a szabályok között. A szabályt a következő képletekkel számolom\+:

1) Alapesetben\+:

\$\$ \textbackslash{}vec\{a\} = \textbackslash{}left( \textbackslash{}vec\{d\} \textbackslash{}cdot d \textbackslash{}right) \textbackslash{}cdot S \$\$

2) Ha az irányvektor (\$\textbackslash{}vec\{d\}\$) és a Boid sebességének (\$\textbackslash{}vec\{v\}\$) skaláris szorzata negatív, akkor a gyorsulás az irányvektor, és egy empirikusan meghatározott korrekciós tényező (\$breakin\+Force\$) szorzatára módosul\+:

\$\$ \textbackslash{}vec\{d\} \textbackslash{}cdot \textbackslash{}vec\{v\} $<$ 0 \textbackslash{}quad \textbackslash{}\+Rightarrow \textbackslash{}quad \textbackslash{}vec\{a\} = \textbackslash{}vec\{d\} \textbackslash{}cdot breaking\+Force \textbackslash{}cdot S \$\$

3) Ha a Boid sebességének harmada nagyobb, mint a célponttól való távolság (\$d\$), és az irányvektor és a sebesség skaláris szorzata pozitív, akkor a gyorsulás egy másik korrekciós tényezővel módosul, amelyet a sebesség és az irányvektor vetülete alapján számolunk ki\+:

\$\$ \textbackslash{}frac\{$\vert$\textbackslash{}vec\{v\}$\vert$\}\{3\} $>$ d \textbackslash{}quad \textbackslash{}text\{és\} \textbackslash{}quad \textbackslash{}vec\{d\} \textbackslash{}cdot \textbackslash{}vec\{v\} $>$ 0 \$\$

\$\$ \textbackslash{}\+Rightarrow \$\$

\$\$ correction\+Factor = -\/ ( breaking\+Force \textbackslash{}cdot $\vert$\textbackslash{}vec\{v\}$\vert$) \$\$

\$\$ \textbackslash{}vec\{a\} = \textbackslash{}vec\{d\}.proj(\textbackslash{}vec\{v\}) \textbackslash{}cdot correction\+Factor \$\$

ahol\+:


\begin{DoxyItemize}
\item $ d $ a célpont és a Boid közötti távolság (distance),
\item $ \vec{d} $ az irányvektor (direction),
\item $ \vec{v} $ a sebesség (speed),
\item $ \vec{a} $ a gyorsulás (acceleration),
\item $ S $ a szabály erőssége (rule\+Strength)
\item $ breakingForce = 30 $, ez egy empirikusan meghatározott konstans.
\end{DoxyItemize}\hypertarget{index_autotoc_md10}{}\doxysubsection{Separation\+Rule}\label{index_autotoc_md10}
A Separation (\char`\"{}\+Szeparáció\char`\"{}) szabály megvalósításáért felelős osztály. A \mbox{\hyperlink{classRule}{Rule}} osztályból származtatom, így megkapta annak interfészét is. A szabály által szolgáltatott gyorsulás komponens számolásáért a {\itshape calculate\+Rule\+For\+Individual\+Impl} függvény felelős, ezt a CRTP tervezés miatt a {\itshape calculate\+Rule\+For\+Individual} függvény hívja meg. Ezt a szabályt tartom a második legfontosabbnak, ugyanis szerintem a kurzor üldözése mellett a másik legfontosabb dolga a Boidoknak, hogy ne ütközzenek össze. A tömegük azért szerepel ebben az egyenletekben, mert ez arányos az őket reprezentáló körökkel, így a képernyőn lévő méretükkel. A szabályt a következő képletekkel számolom (a \$scaling\+Factor\$ számolása a lényeges)\+:


\begin{DoxyEnumerate}
\item Amennyiben a Boidok nagyon közel vannak egymáshoz\+:

\$\$ distance $<$ M\+\_\+i + M\+\_\+o + \textbackslash{}frac\{desired\+Minimal\+Distance\}\{3\} \textbackslash{}quad \textbackslash{}\+Rightarrow \textbackslash{}quad scaling\+Factor = empiric\+Scaling\+Value \$\$
\item Amennyiben a kívánt távolságnál közelebb, de a fentebbinél távolabb helyezkednek el\+:

\$\$ M\+\_\+i + M\+\_\+o+ \textbackslash{}frac\{desired\+Minimal\+Distance\}\{3\} \textbackslash{}leq distance \textbackslash{}leq M\+\_\+i + M\+\_\+o + desired\+Minimal\+Distance \textbackslash{}\+Rightarrow scaling\+Factor = \textbackslash{}frac\{1\}\{distance -\/ (M\+\_\+i + M\+\_\+o)\} \$\$
\item Amennyiben a kívánt határon kívül helyezkednek el, és a vizsgált Boid látóterében van a másik Boid\+:

\$\$ M\+\_\+i + M\+\_\+o+ desired\+Minimal\+Distance \textbackslash{}ge distance \textbackslash{}quad \textbackslash{}text\{és\} \textbackslash{}quad \textbackslash{}vec\{d\}.angle\+With(\textbackslash{}vec\{v\}) \textbackslash{}leq \textbackslash{}frac\{\textbackslash{}pi\}\{3\} \textbackslash{}quad \textbackslash{}\+Rightarrow \textbackslash{}quad scaling\+Factor = \textbackslash{}frac\{M\+\_\+i + M\+\_\+o\}\{distance$^\wedge$2\} \$\$ Így a szabály által visszaadott gyorsulás komponens\+: \$\$ \textbackslash{}vec\{a\} = \textbackslash{}vec\{d\} \textbackslash{}cdot scaling\+Factor \textbackslash{}cdot S \$\$
\end{DoxyEnumerate}

ahol\+:


\begin{DoxyItemize}
\item $ M_i $\+: A vizsgált Boid tömege (individual.\+get\+Mass()),
\item $ M_o $\+: A másik Boid, amelyikkel éppen vizsgáljuk a vizsgált egyedünket (current\+Flock\+Memberget\+Mass()),
\item $ scalingFactor $\+: A skálázó faktor, amellyel az irányvektort szorozni fogjuk,
\item $ \vec{d} $\+: Az irányvektor (direction)
\item $ \vec{a} $ a gyorsulás (acceleration),
\item $ distance $\+: A két Boid közötti távolság (distance)
\item $ desiredMinimalDistance = 150 $ \mbox{[}pixel\mbox{]}
\item $ empiricScalingValue = 500 $
\item $ S $\+: Szabály erőssége (rule\+Strength)
\end{DoxyItemize}\hypertarget{index_autotoc_md11}{}\doxysubsection{Cohesion\+Rule}\label{index_autotoc_md11}
A Cohesion (\char`\"{}\+Kohézió\char`\"{}) szabály megvalósításáért felelős osztály. Ez a szabály felelős azért, hogy a Boidok mindig a raj tömegközéppontja felé is gyorsuljanak, és nehezebben szakadjanak le a rajtól. A \mbox{\hyperlink{classRule}{Rule}} osztályból származtatom, így megkapta annak interfészét is. A szabály által szolgáltatott gyorsulás komponens számolásáért a {\itshape calculate\+Rule\+For\+Individual\+Impl} függvény felelős, ezt a CRTP tervezés miatt a {\itshape calculate\+Rule\+For\+Individual} függvény hívja meg. Ennél a szabálynál a lényegi számolás a raj tömegközéppontjának számolásában rejlik, ez a következő módon írható le\+:


\begin{DoxyEnumerate}
\item A tömegközéppont kiszámítása során a Boidok tömegével súlyozottan átlagoljuk a helyvektoraikat, majd leosztunk a nyáj össztömegével\+:

\$\$ \textbackslash{}vec\{C\} = \textbackslash{}frac\{1\}\{M\} \textbackslash{}sum\+\_\+\{i = 1\}$^\wedge$N \textbackslash{}vec\{p\+\_\+i\} \textbackslash{}cdot m\+\_\+i \$\$
\item Innen az irányvektor\+:

\$\$ \textbackslash{}vec\{d\} = \textbackslash{}vec\{C\} -\/ \textbackslash{}vec\{p\+\_\+b\} \$\$
\item Majd a visszaadott gyorsulásvektor\+:

\$\$ \textbackslash{}vec\{a\} = \textbackslash{}vec\{d\} \textbackslash{}cdot S \$\$
\end{DoxyEnumerate}

ahol\+:


\begin{DoxyItemize}
\item $ \vec{C} $ a tömegközéppontba mutató vektor (common\+Center\+Of\+Mass),
\item $ M $\+: A raj össztömege (sum\+Of\+Masses),
\item $ \vec{a} $ a gyorsulás (return value),
\item $ \vec{p_b} $ a vizsgált Boid helyvektora(boid.\+get\+Position()),
\item $ \vec{d} $\+: Az irányvektor (direction),
\item $ S $\+: Szabály erőssége (rule\+Strength).
\end{DoxyItemize}\hypertarget{index_autotoc_md12}{}\doxysubsection{Alignment\+Rule}\label{index_autotoc_md12}
Az Alignment (\char`\"{}\+Igazodás\char`\"{}) szabály megvalósításáért felelős osztály. Ez a szabály felelős azért, hogy a Boidok próbálják meg felvenni környezetük átlagos sebességét, ezzel valamivel természetesebb, rajmozgásra jobban emlékeztető mozgást végezni. Ezt a szabályt különösen nehéz volt beállítani, ugyanis a többinél is gyorsabban túllövésekhez, illetve nagy kilengésekhez vezethet. A \mbox{\hyperlink{classRule}{Rule}} osztályból származtatom, így megkapta annak interfészét is. A szabály által szolgáltatott gyorsulás komponens számolásáért a {\itshape calculate\+Rule\+For\+Individual\+Impl} függvény felelős, ezt a CRTP tervezés miatt a {\itshape calculate\+Rule\+For\+Individual} függvény hívja meg. Ennél a szabálynál a lényegi számolás a közeli szomszédok sebességeinek kiátlagolásában rejlik. Egyesével eldöntjük, hogy a raj mely tagjai vannak elég közel a vizsgált egyedhez, majd azokat, amelyek elég közel vannak a következő képlet alapján összegezzük\+:

\$\$ \textbackslash{}vec\{a\} = \textbackslash{}frac\{\textbackslash{}sum\+\_\+\{i = 0\}$^\wedge$N \textbackslash{}vec\{v\+\_\+i\} \textbackslash{}cdot correction\+Factor\}\{\textbackslash{}sum\+\_\+\{i = 0\}$^\wedge$N $\vert$\textbackslash{}vec\{v\+\_\+i\}$\vert$ \textbackslash{}cdot N\} \textbackslash{}cdot S \$\$

ahol\+:


\begin{DoxyItemize}
\item $ N $\+: A rajból a releváns egyedek száma (affecting\+Members),
\item $ \vec{v_i} $ a raj releváns egyedeinek sebességvektorai,
\item $ \vec{a} $ a gyorsulás (return value),
\item $ S $\+: Szabály erőssége (rule\+Strength).
\item $ correctionFactor $ = 10000, egy empirikusan meghatározott korrekciós állandó (CORRECTION\+\_\+\+FACTOR).
\end{DoxyItemize}\hypertarget{index_autotoc_md13}{}\doxysection{Memóriaszivárgás \char`\"{}problémák\char`\"{}}\label{index_autotoc_md13}
A program az SFML 2.\+5.\+1 verzióját használja. Több memóriaszivárgást tesztelő programmal is teszteltem (Memtrace, Dr. Memory, Valgrind), és memóriaszivárgásokat találtam, amelyek az SFML használatából erednek. Ha az SFML-\/hez kapcsolódó részeket eltávolítjuk, a program nem mutat memóriaszivárgást. A program sehol sem tartalmaz nyers pointerekkel történő dinamikus memóriakezelést, így biztosan nem valós pozitív ezeknek a vizsgáló eszközöknek a kimenete. Az alábbi forrásokat találtam a probléma megértéséhez, bár még nem sikerült teljesen rájönnöm a memóriaszivárgás okára\+:


\begin{DoxyItemize}
\item \href{https://github.com/SFML/SFML/issues/1673}{\texttt{ SFML Issue \#1673}}
\item \href{https://en.sfml-dev.org/forums/index.php?topic=27777.0}{\texttt{ SFML Fórum}}
\end{DoxyItemize}\hypertarget{index_autotoc_md14}{}\doxysubsection{Memóriaszivárgáshoz kapcsolódóan}\label{index_autotoc_md14}
Amennyiben a Memtrace mellett szeretnénk elindítani a programot, az a {\itshape window} generálásánál egyből kidob, a problémán jelenleg dolgozom még. 