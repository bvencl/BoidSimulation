<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Rajzásszimuláció: Bódi Vencel VBW5N9</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js.js", "TeX/AMSsymbols.js.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Rajzásszimuláció
   &#160;<span id="projectnumber">6.9</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Készítette Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Keresés','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Keresés');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Bódi Vencel VBW5N9 </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md_README"></a> </p>
<h1><a class="anchor" id="autotoc_md1"></a>
A projekt rövid bemutatása</h1>
<p>Ez a projekt egy raj (nyáj) mozgásának szimulációját valósítja meg két dimenzióban. A raj tagjai különféle szabályok szerint mozognak, amelyek befolyásolják a gyorsulásukat és így a sebességüket is. A grafikus megjelenítéshez az SFML 2.5.1-es verzót használom. A szimuláció célja a természetben megfigyelhető rajmozgás, rajintelligencia és a különböző viselkedésű rajok modellezése. A rajok egyes egyedei az alábbi négy szabály szerint mozognak:</p>
<p>1) <b>Chasing (Üldözés)</b>: Minden egyed egy közös célpontot, jelen esetben az egérkurzort "kergeti", azaz felé gyorsul.</p>
<p>2) <b>Separation (Szeparáció)</b>: Az egyedek taszító erőt éreznek a többi egyedtől, és próbálnak távolodni, hogy elkerüljék az ütközést.</p>
<p>3) <b>Cohesion (Kohézió)</b>: Az egyedek a közvetlen szomszédaik tömegközéppontja felé gyorsulnak, így összetartóbbá válik a mozgásuk.</p>
<p>4) <b>Alignment (Igazodás)</b>: Az egyedek a közvetlen szomszédaik sebességét próbálják felvenni, így egymáshoz igazodva mozognak.</p>
<p>Az alábbiakban ismeretetem a program használatát, felépítését, az egyes tervezési döntések mögötti okokat és esetleges fennmaradt kérdéseket és problémákat, majd kitérek a jövőbeli fejlesztési és bővítési lehetőségekre.</p>
<h1><a class="anchor" id="autotoc_md2"></a>
Használat</h1>
<p>A projekt tartalmaz egy Makefile-t, amely Windows és UNIX alapú operációs rendszereken egyaránt működik (Windows 11-en és Ubuntu 22.04 LTS-en fejlesztettem és teszteltem).</p>
<h2><a class="anchor" id="autotoc_md3"></a>
Fordítás és futtatás</h2>
<p>1) <b>Fordítás:</b> A Makefile segítségével az alábbi módon egyszerűen fordíthatod: cd codes make</p>
<p>Illetve ha debug módban szeretnéd elindítani (nem feltétlenül ajánlott, egy kiválasztott egyed aktuális pozíciója kiíródik minden időlépésben): cd codes make debug</p>
<p>2) <b>A program indítása</b>: </p><pre class="fragment">   cd bin
   .\main.exe param1 param2
</pre><p> ahol:</p>
<ul>
<li>param1 a megjelenő ablak kívánt szélessége pixelben (alapból 1920)</li>
<li>param2 a megjelenő ablak kívánt magassága pixelben (alapból 1080)</li>
</ul>
<p>3) <b>Boid-ok számának megadása</b>:</p>
<p>Ezután a terminálban kell megadni a szimulációban részt vevő egyedek számát. <br  />
</p>
<h1><a class="anchor" id="autotoc_md4"></a>
Memóriaszivárgás "problémák"</h1>
<p>A program az SFML 2.5.1 verzióját használja. Több memóriaszivárgást tesztelő programmal is teszteltem (Memtrace, Dr. Memory, Valgrind), és memóriaszivárgásokat találtam, amelyek az SFML használatából erednek. Ha az SFML-hez kapcsolódó részeket eltávolítjuk, a program nem mutat memóriaszivárgást. A program sehol sem tartalmaz nyers pointerekkel történő dinamikus memóriakezelést, így biztosan nem valós pozitív ezeknek a vizsgáló eszközöknek a kimenete. Az alábbi forrásokat találtam a probléma megértéséhez, bár még nem sikerült teljesen rájönnöm a memóriaszivárgás okára:</p>
<ul>
<li><a href="https://github.com/SFML/SFML/issues/1673">SFML Issue #1673</a></li>
<li><a href="https://en.sfml-dev.org/forums/index.php?topic=27777.0">SFML Fórum</a></li>
</ul>
<h2><a class="anchor" id="autotoc_md5"></a>
Memóriaszivárgáshoz kapcsolódóan</h2>
<p>Amennyiben a Memtrace mellett szeretnénk elindítani a programot, az a <em>window</em> generálásánál egyből kidob, a problémán jelenleg dolgozom még.</p>
<h1><a class="anchor" id="autotoc_md6"></a>
A programról</h1>
<h2><a class="anchor" id="autotoc_md7"></a>
Osztályok, jelentésük, használatuk</h2>
<h3><a class="anchor" id="autotoc_md8"></a>
Vector osztály</h3>
<p>Az általam definiált <a class="el" href="classVector.html" title="Az osztály, amely egy kétdimenziós vektort reprezentál. Vektorműveletekhez használom ezt az osztályt,...">Vector</a> osztály egy kétdimenziós vektort valósít meg. Matematikai műveletek elvégzéséhez deiniáltam ezt az osztályt, ugyanis erre nincsen külön STL-beli előre definiált osztály. A programban mindenhol használom ezt az osztályt, ugyanis a szimulációnál a számítások túlnyomó része a vektoralgebra területéhez tartozik.</p>
<h3><a class="anchor" id="autotoc_md9"></a>
BasicBoid osztály</h3>
<p>A Boid elnevezés Craig Reynolds 1986-os Boids névvel ellátott mesterséges élet projektjéből származik. A Boidok aktuális álllapotát négy változóval modellezem:</p>
<ul>
<li><b>speed</b>: A Boidok sebességét tároló <em><a class="el" href="classVector.html" title="Az osztály, amely egy kétdimenziós vektort reprezentál. Vektorműveletekhez használom ezt az osztályt,...">Vector</a></em>, amely alapján a Boid pozícióját számolom.</li>
<li><b>acceleration</b>: A Boidok gyorsulását tároló <em><a class="el" href="classVector.html" title="Az osztály, amely egy kétdimenziós vektort reprezentál. Vektorműveletekhez használom ezt az osztályt,...">Vector</a></em>, amely alapjén a Boid sebességét számolom.</li>
<li><b>currentPosition</b>: A Boidok aktuális pozícióját tároló <em><a class="el" href="classVector.html" title="Az osztály, amely egy kétdimenziós vektort reprezentál. Vektorműveletekhez használom ezt az osztályt,...">Vector</a></em>. Ennek <em>sf::Vector2f</em> típusra való kasztolásával tudom megjeleníteni a Boidokat.</li>
<li><b>mass</b>: A Boidok tömegét tároló <em>double</em> érték. Ugyan ezzel a számértékkel inicializálom az egyes Boidokhoz tartozó alakzatokat is, így a nagyobb Boidokhoz nagyobb mértet is tudunk rendelni.</li>
</ul>
<p>Ezzel a négy változóval teljesen leírható a Boidok minden időpillanatban vett aktuális állapota. A Boidok mozgásánál a koncepcióm az volt, hogy az egyedek szabadon váktoztathatják gyorsulásukat, ugyanakkor a sebességük csak és kizárólag a gyorsulásukon keresztül változtatható, azaz nem felülírható sebességük az erre kijelült metóduson kívül sehol. A Boidok mozgatását a MyTurn metódussal végzem. Ez egyszerűen a paraméterül kapott gyorsulással felülírja a Boid aktuális gyorsulását, majd kiszámítja a "pillanatnyi sebességét" és ez alapján meghatározza a Boid pillanatnyi pozícióját. Kísérletezés képpen néhány szabálynál (a szabályokról később írok részletesebben) figyelembe vettem, hogy a Boidoknak van "látótere". A látótér közepének a sebességet vettem, azaz minden egyed a sebességével folyamatosan egy irányba néz. Ebből adódóan kellő távon kívül csak olyan más egyedeket képesek észlelni, amelyek benne vannak a látóterükben. (Ilyen például a <a class="el" href="classSeparationRule.html" title="Az osztály, amely a Separation (&quot;Szeparáció&quot;) szabályt valósítja meg.">SeparationRule</a>. A gyakorlatban talán ez azt jelenthetné, hogy azt a társát nem fogja megpróbálni kikerülni, amelyikről nem tud, azaz a másik fog csak lelassítani, amelyik észleli a vele szemben lévő egyedet. Bizonyos távolságban ugyanakkor mindenképpen észlelik a környezetükben lévő társaikat, ezt akár felfoghatjuk úgy is, hogy "meghallják" társaikat.)</p>
<h3><a class="anchor" id="autotoc_md10"></a>
Flock osztály</h3>
<p>A <a class="el" href="classFlock.html" title="A nyáj osztály, amely tartalmazza a Boidokat és a nyáj szabályait.">Flock</a> osztály a Boidokból álló rajt hivatott reprezentálni. Az egy rajba rendezett egyedek tudnak egymásra reagálni, más rajokkal egyelőre nem képesek interaktálni, ugyanakkor van lehetőség több raj létrehozására. A Boidokat jelen megvalósításban egy std::vector-ban tárolom, ugyanakkor minden metódus úgy van implementálva, hogy ezt másféle STL-kompatibilis konténerrel is végezhetnénk. A raj szabályainak szabály-erősségét jelenleg annak példányosításakor lehet beállítani, ugyanis a raj tartalmazza a rajta értelmezett szabály-példányokat (ezt a jövőben szeretném még átalakítani). A <a class="el" href="classFlock.html" title="A nyáj osztály, amely tartalmazza a Boidokat és a nyáj szabályait.">Flock</a> legfőbb metódusa a moveFlock, ez felel a raj szabályainak alkalmazásáról, itt számolódik minden Boid pillanatbeli gyorsulás értéke, és ezt adja tovább a Boidok MyTurn függvényének (az engineTime aktuális értékével együtt).</p>
<h3><a class="anchor" id="autotoc_md11"></a>
Rule osztály</h3>
<p>A <a class="el" href="classRule.html" title="Absztrakt sablon osztály, CRTP (Curiously Recurring Template Pattern) alapján, a szabály-osztályok ős...">Rule</a> osztály a három Boidok között ható szabály-osztály ősosztálya. Az osztály a CRTP (Curiously Recrring Template Pattern) tervezési minta szerint lett tervezve, aminek lényege, hogy az ősosztály paraméterben megkaphatja a belőle származtatott osztályt. Ez a minta teszi lehetővé, hogy az ősosztályban definiáljunk olyan metódsukoat, amelyek a szűrmaztatott osztály metódusait képesek meghívni. Erre a tervezési mintára jelen esetben azért van szükség, mert ha szerenénk a <a class="el" href="classFlock.html" title="A nyáj osztály, amely tartalmazza a Boidokat és a nyáj szabályait.">Flock</a> osztályban más fajta STL kompatibilis tárolóban tárolni a <a class="el" href="classBasicBoid.html" title="Az alapvető egyedeket reprezentáló osztály. Az osztály, ezzel az egyedek Craig Reynolds 1986-os &quot;Boid...">BasicBoid</a> objektumainkat, akkor így nem kell módosítanunk semmit sem a szabályok implementációján, teljesen függetlenek a kapott tároló fajtájától. Ezeken felül a <a class="el" href="classRule.html" title="Absztrakt sablon osztály, CRTP (Curiously Recurring Template Pattern) alapján, a szabály-osztályok ős...">Rule</a> osztály koherens interfészt szolgáltat a három olyan szabálnyak, amelyek a Boidok között hatnak (ezek a Separation, Cohesion és Alignment). A Chasing szabály azért nem ebből az osztályból származik, mert ugyan hasonló interfésze van a többi szabályhoz, ugyanakkor csupán az aktuálisan vizsgált egyedre, és a kurzor pozíciójára van szüksége a számytásokhoz, nem igényli az egész raj ismeretét.</p>
<h3><a class="anchor" id="autotoc_md12"></a>
ChasingRule osztály</h3>
<p>A Chasing ("Üldözés") szabály mevalósításáért felelős osztály. A kurzor és a paraméterül kapott Boid pozíciójából számolja a gyorsulást, amellyel a Boid a kurzor felé fog gyorsulni az adott időpillanatban. Erre a szabályra fektettem a legnagyobb hangsúlyt, ugyanis szerintem ez a leglátványosabb a szabályok között, ugyanakkor még mindig nem vagyok teljesen elégedett vele, szeretnék még finomítani rajta. A szabályt a következő képletekkel számolom:</p>
<p>1) Alapesetben:</p>
<p>$$ \vec{a} = \left( \vec{d} \cdot d \right) \cdot S $$</p>
<p>2) Ha az irányvektor ($\vec{d}$) és a Boid sebességének ($\vec{v}$) skaláris szorzata negatív, akkor a gyorsulás az irányvektor, és egy empirikusan meghatározott korrekciós tényező ($breakinForce$) szorzatára módosul:</p>
<p>$$ \vec{d} \cdot \vec{v} &lt; 0 \quad \Rightarrow \quad \vec{a} = \vec{d} \cdot breakingForce \cdot S $$</p>
<p>3) Ha a Boid sebességének harmada nagyobb, mint a célponttól való távolság ($d$), és az irányvektor és a sebesség skaláris szorzata pozitív, akkor a gyorsulás egy másik korrekciós tényezővel módosul, amelyet a sebesség és az irányvektor vetülete alapján számolunk ki:</p>
<p>$$ \frac{|\vec{v}|}{3} &gt; d \quad \text{és} \quad \vec{d} \cdot \vec{v} &gt; 0 $$</p>
<p>$$ \Rightarrow $$</p>
<p>$$ correctionFactor = - ( breakingForce \cdot |\vec{v}|) $$</p>
<p>$$ \vec{a} = \vec{d}.proj(\vec{v}) \cdot correctionFactor $$</p>
<p>ahol:</p>
<ul>
<li>\( d \) a célpont és a Boid közötti távolság (distance),</li>
<li>\( \vec{d} \) az irányvektor (direction),</li>
<li>\( \vec{v} \) a sebesség (speed),</li>
<li>\( \vec{a} \) a gyorsulás (acceleration),</li>
<li>\( S \) a szabály erőssége (ruleStrength)</li>
<li>\( breakingForce = 30 \), ez egy empirikusan meghatározott konstans.</li>
</ul>
<h3><a class="anchor" id="autotoc_md13"></a>
SeparationRule osztály</h3>
<p>A Separation ("Szeparáció") szabály megvalósításáért felelős osztály. A <a class="el" href="classRule.html" title="Absztrakt sablon osztály, CRTP (Curiously Recurring Template Pattern) alapján, a szabály-osztályok ős...">Rule</a> osztályból származtatom, így megkapta annak interfészét is. A szabály által szolgáltatott gyorsulás komponens számolásáért a <em>calculateRuleForIndividualImpl</em> függvény felelős, ezt a CRTP tervezés miatt a <em>calcualateRuleForIndividual</em> függvény hívja meg. Ezt a szabályt tartom a második legfontosabbnak, ugyanis szerintem a kurzor üldözése mellett a másik legfontosabb dolga a Boidoknak, hogy ne ütközzenek össze. A tömegük azért szerepel ebben az egyenletben, mert ez arányos az őket reprezentáló körökkel, így a képernyőn lévő méretükkel. A szabályt a következő képletekkel számolom (a $scalingFactor$ számolása a lényeges):</p>
<ol type="1">
<li><p class="startli">Amennyiben a Boidok nagyon közel vannak egymáshoz:</p>
<p class="startli">$$ distance &lt; M_i + M_o + \frac{desiredMinimalDistance}{3} \quad \Rightarrow \quad scalingFactor = empiricScalingValue $$</p>
</li>
<li><p class="startli">Amennyiben a kívánt távolságnál közelebb, de a fentebbinél távolabb helyezkednek el:</p>
<p class="startli">$$ M_i + M_o+ \frac{desiredMinimalDistance}{3} \leq distance \leq M_i + M_o + desiredMinimalDistance \Rightarrow scalingFactor = \frac{1}{distance - (M_i + M_o)} $$</p>
</li>
<li><p class="startli">Amennyiben a kívánt határon kívül helyezkednek el, és a vizsgált Boid látóterében van a másik Boid:</p>
<p class="startli">$$ M_i + M_o+ desiredMinimalDistance \ge distance \quad \text{és} \quad \vec{d}.angleWith(\vec{v}) \leq \frac{\pi}{3} \quad \Rightarrow \quad scalingFactor = \frac{M_i + M_o}{distance^2} $$ Így a szabály által visszaadott gyorsulás komponens: $$ \vec{a} = \vec{d} \cdot scalingFactor \cdot S $$</p>
</li>
</ol>
<p>ahol:</p>
<ul>
<li>\( M_i \): A vizsgált Boid tömege (individual.getMass()),</li>
<li>\( M_o \): A másik Boid, amelyikkel éppen vizsgáljuk a vizsgált egyedünket (currentFlockMembergetMass()),</li>
<li>\( scalingFactor \): A skálázó faktor, amellyel az irányvektort szorozni fogjuk,</li>
<li>\( \vec{d} \): Az irányvektor (direction)</li>
<li>\( \vec{a} \) a gyorsulás (acceleration),</li>
<li>\( distance \): A két Boid közötti távolság (distance)</li>
<li>\( desiredMinimalDistance = 150 \) [pixel]</li>
<li>\( empiricScalingValue = 500 \)</li>
<li>\( S \): Szabály erőssége (ruleStrength)</li>
</ul>
<h3><a class="anchor" id="autotoc_md14"></a>
CohesionRule osztály</h3>
<p>A Cohesion ("Kohézió") szabály megvalósításáért felelős osztály. Ez a szabály felelős azért, hogy a Boidok mindig a raj tömegközéppontja felé is gyorsuljanak, és nehezebben szakadjanak le a rajtól. A <a class="el" href="classRule.html" title="Absztrakt sablon osztály, CRTP (Curiously Recurring Template Pattern) alapján, a szabály-osztályok ős...">Rule</a> osztályból származtatom, így megkapta annak interfészét is. A szabály által szolgáltatott gyorsulás komponens számolásáért a <em>calculateRuleForIndividualImpl</em> függvény felelős, ezt a CRTP tervezés miatt a <em>calcualateRuleForIndividual</em> függvény hívja meg. Ennél a szabálynál a lényegi számolás a raj tömegközéppontjának számolásában rejlik, ez a következő módon írható le:</p>
<ol type="1">
<li><p class="startli">A tömegközéppont kiszámítása során a Boidok tömegével súlyozottan átlagoljuk a helyvektoraikat, majd leosztunk a nyáj össztömegével:</p>
<p class="startli">$$ \vec{C} = \frac{1}{M} \sum_{i = 1}^N \vec{p_i} \cdot m_i $$</p>
</li>
<li><p class="startli">Innen az irányvektor:</p>
<p class="startli">$$ \vec{d} = \vec{C} - \vec{p_b} $$</p>
</li>
<li><p class="startli">Majd a visszaadott gyorsulásvektor:</p>
<p class="startli">$$ \vec{a} = \vec{d} \cdot S $$</p>
</li>
</ol>
<p>ahol:</p>
<ul>
<li>\( \vec{C} \) a tömegközéppontba mutató vektor (commonCenterOfMass),</li>
<li>\( M \): A raj össztömege (sumOfMasses),</li>
<li>\( \vec{a} \) a gyorsulás (return value),</li>
<li>\( \vec{p_b} \) a vizsgált Boid helyvektora(boid.getPosition()),</li>
<li>\( \vec{d} \): Az irányvektor (direction),</li>
<li>\( S \): Szabály erőssége (ruleStrength). </li>
</ul>
</div></div><!-- PageDoc -->
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Készítette&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
